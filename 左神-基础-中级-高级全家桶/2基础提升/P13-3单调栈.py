''''''
'''
arr求每个位置左右离他最近的比他大的数是谁？代价低。O(N)

暴力姐：以每个位置为中心，扩。O(N^2)


1.设arr无重复。   


        arr    [5 4 3 6 1 2 0 7]
        位置     0 1 2 3 4 5 6 7
        
stack：保证从栈底-->栈顶  位置代表的数从大到小，还是放下标。

求最大值stack就是大--小，最小值就是小--大。



规则：cur是当前数，小于栈顶，push进来；大于栈顶，一直pop直到满足。
    
    左右信息在pop时产生。栈顶的右边最近的大数就是当前数cur，左边就是它压着的数。
    
    (1)stack:[0],i=1,5>4，push，stack:[0 1]
    (2)i=2 3<4,push,stack:[0 1 2]
    (3)i=3 3<6,栈顶2位置的右侧最近大数就是i=3位置，左侧就是1位置,pop,stack[0 1]
    (4)i=3 4<6 栈顶1位置右侧最近是i=3位置，左侧是0位置,pop stack[0]
    (5)i=3 5<6 0位置右侧是i=3，左侧没有，pop stack[]
    (6)stack空 i=3直接进 stack[3]
    ...继续
    直到i结束，stack有数字，依次pop清算即可，每次pop都是只有左边最大，没有右边。因为没有当前数了。
    
    
    每个位置都进栈依次出栈一次，就生成了所有信息，所以时间是O(N)
    

证明：

    假设当前 stack[b a]   c大于a，a的右是c左是b为什么是对的。
    
    a...c   c一定在a右边，ac中间的数不可能大于a，因为那样的话栈顶就不是a了，已经被中间大的数弹出去了。
    
    所以只可能是c是离a最近的比a大的数。 
    
    b...a  b一定在a左边，b>a。    如果中间的数大于b，那在它出现的时候b就pop了，b就不会在a下面，所以中间不会大于b。 
                              如果 a<中间数<b，那它会留在ba中间。
        所以中间数一定小于a，那b就是a左侧最近的大数。
        
2.有重复值，下标放一起即可。pop是两个依次生成，压在一起的数的左右值是一样的。

        arr 5 4 3 4 5 3 5 6
            0 1 2 3 4 5 6 7      
（1）st=[0]
（2）st=[0 1]
（3）st=[0 1 2]
（4）3位置的4大于2位置的3，2位置右是3，左是1，pop,st=[0 1]
（5）3位置3与1位置3一样，放一起 st=[0 [1 3]]
（6）4位置5比1、3位置的4大，1位置右是4，左是0，pop；3位置右是4，左是0，pop；4push st=[0 4]
...继续


'''

# --------------------- 应用-----------------#
'''
正数arr，元素和 * 最小值 = 指标A，求子数组中A最大的值。

   5 3 2 1 6 7 4 8
   
i遍历每个位置，求每个以i为最小值，且累加和最大的子数组。
（1）i=5，以5为最小值，不能扩，因为那样5就不是最小，[5]
（2）i=3，3最小，和最大，[5,3]
（3）i=2 [5,3,2]
（4）i=1 [5,3,2,1,6,7,4,8]
        ...
求所有，取最大。

就是单调栈。i位置左边最近右边最近比他小的是他不能扩的位置，这样能求出每个位置最大范围。




'''