'''
'''

# ------------------- 1.暴力姐 ---------------#
'''
以每个位置为中心，向两边扩，求最大即可。

但是长度是偶数的回文是得不到的！因为偶数的对称轴是虚轴！如12213按这个方法的答案是1，1221的答案丢了。

技巧，插入
    #1#2#2#1#3#
    即可。
长度为9，结果为 9 // 2 = 4，奇偶回文都能找到。

但是时间O(N^2)
    
    
Manacher在此过程上进行的加速。
'''
# ------------------------------------------- #
# ------------------- 2. 回文半径与回文直径---------------#
'''
以某个中心扩出的整个长度是回文直径，一半是半径。
    
    #a#1#2#1#b#

2的回文半径=4，直径=7
每个位置的回文半径记入help数组中。
'''
# ------------------------------------------- #
# ------------------- 3.最右回文右边界---------------#
'''
之前所到的所有位置中最右回文右边界。

初始 R = -1，遍历过程中R不断更新变大。
    |
    v 
    )#1#2#2#1# 
   -1012345678
取得最远R时的中心点C，与R同步更新。最终R=8，C=4
'''

# ------------------------------------------- #
# ------------------- 4.Manacher流程---------------#
'''
i为当前位置

情况1：i>R，在边界外，没有优化，以i为中心暴力扩，找最长半径与R；
    举例：如开始时R=-1，i=0，i在R之外，i暴力扩，半径为1，R=0；
    i=1时，i>R，暴力扩，半径为2，R=2；
    i=2时，i=R，在范围内，进入可优化的情况2
  )#1#2#2#1# 
 -1012345678

情况2：i在R内部，C一定在i左边，i'是i关于C的对称点，关系如下
        
         [   o      o      o   ]
         L   i'     C      i   R
根据i'的回文状况分为3类：

（1）i'的回文区域在LR中，
         [ ( o )   o      o   ]
         L   i'    C      i   R    
如   [ a b c b d k s k d b c b a ]
     L  (  i' )    C    (  i  )  R
     
此时i为i'的答案一样。不会更大，反证法。
        如果i的半径比i'大，设i'半径前x后y，i前p后q，即
        L...x(...i'...)y ... C ... p(...i...)q...R
        
若i的范围多了pq，因为C的回文，所以p=y，x=q，得到x=y，那就是i'的半径比条件大，所以不可能！

（2）i'的回文区域在LR外面
        （ [   o    ） o      o   ]
           L   i'     C      i   R   

      a b [ c d e d c b a k a b c d e d c ] f t
     (    L     i'       )C         i     R

此时i的回文半径就是i-R的距离，不会更长，反证。i前
      
      (...xL...i'...L'y.)..C...p(R'...i...R)q

假设p=q，因为C回文，p=y,x=y得到x=q，这样C的半径就大于R了。
      
      
（3）i'回文恰好在L上压线。
         [   o     o      o   ]
         L   i'    C      i   R   
         (       )
    [ a b c d c b a k s k a b c d b c a ]  
    L(      i'     )C           i       R

此时i与i'对应的部分一定回文，不用看了，从R的下一个位置继续验证，有可能回文。
--------------------------------------------------

            伪代码与复杂度分析

def manacher(s):
    # 预处理数组 1221 -- > #1#2#2#1#
    s - > str
    
    pArr = [0] * len(str)    # 最长回文半径的数组
    
    更新量
    R = -1
    C= -1
    
    for i in range(len(str)):
        if i在R外部:
            从i向两边暴力扩-->R变大
        
        else:
            if i'回文区域彻底在L..R范围内:
                pArr[i] = 某个O(1)表达式，直接答案
            
            elif i'回文区域有一部分在L范围之外:
                pArr[i] = 某个O(1)表达式，直接答案
                
            else:   压线
                从R外的第一个字符开始外扩，确定pArr[i]
                -->第一次就失败，R不变；否则，R变大。

                
    变量    i      R
    分支1  增大    增大
    分支2  增大    不变
    分支3  增大    不变
    分支4  增大    增大
    
i最大到N，R也是最大到N，且只增不退！也就是i每次增大一步，i每增大一步，R可能不变，也可能增大x步。

但是R不会减小，会从之前R的基础上想N增大，所以R会在i的多次迭代过程中完成0-->R的扩大。所以while的整个幅度也就是2N的水平。

Manacher的时间O(N)
                
        
'''

# ------------------------------------------- #
# ------------------- 5.Manacher代码实现---------------#

'''
实现与步骤有代码上的优化，使代码简洁复用，但是读起来可能困难一些。

求最大回文子串长度。

'''
# 预处理数组
def manacherString(s):
    res = '#'
    for i in range(len(s)):
        res += (s[i] + '#')
    return res

def maxLcpsLength(s):
    if s is None or len(s) == 0:
        return 0

    st = manacherString(s)   # 121-> #1#2#1#
    pArr = [0] * len(st)  # 回文半径数组
    C = -1
    R = -1   # todo 不同，为了方便。R是右边界下一个位置，R-1是包含的，R是不包含
    maxValue = float('-inf')    # 记录半径最大值

    for i in range(len(st)):
        # 对每个位置求回文半径

        # todo 重点，4种情况都有至少的回文半径，先把值赋上
        '''
        1. i >= R先把自己加上1，后面再继续扩；
        
        2*C - i就是i'
        2.i 在R内部， 先把i'的半径与R-i的最小值加上。
        即   （1）i'半径在LR内，i'半径小于R-i，加i'半径，就结束了；
             （2）i'半径在L外，R-i小，加上，也结束了；
             （3）压线，这两个值相等的，先加上做小加速，后面再暴力扩；   
        '''

        pArr[i] = min(pArr[2 * C - i], R - i) if R > i else 1

        # todo 暴力扩。不需要扩的直接就结束了，不会进去
        while(i + pArr[i] < len(st) and i - pArr[i] > -1):
            # 不扩的情况进来就停了
            if st[i + pArr[i]] == st[i - pArr[i]]:
                pArr[i] += 1
            # 不等，直接返回
            else:
                break

        # 更远，进行更新
        if i + pArr[i] > R:
            R = i + pArr[i]
            C = i
        maxValue = max(maxValue, pArr[i])

    # todo 关系：处理串的回文半径 - 1 = 原始串的长度
    return maxValue - 1


'''
总结：
1.manacher也是每个位置遍历，但是利用了处理过的回文信息进行加速，达到O(N)
2.回文半径数组很重要，能解决很多回文问题，不只是最长回文字串问题。

'''




