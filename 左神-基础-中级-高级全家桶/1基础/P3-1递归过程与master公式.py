# ------------------- 1.用取最大值来演示递归过程 ------------------- #
# todo 核心：max(左最大, 右最大)
'''
example: [5,4,3,6,8,1] 位置0-5,process(0,5)表示求0-5上的最大
                       p(0, 5)
                   /           \
            p(0, 2)              p(3, 5)
            /    \             /       \
      p(0, 1)     p(2, 2)   p(3, 4)     p(5, 5)
      / \                    /    \
p(0,0) p(1, 1)            p(3,3) p(4,4)

todo 实质：母问题分解为多叉树的子问题，母问题依赖子问题，则母问题压栈，先解决子问题；
    直到叶子节点。
    就是多叉树的后序遍历过程！最后回到母问题，得到最终的解答！
'''

def getMax(arr):
    return process(arr, 0, len(arr) - 1)

def process(arr, left, right):
    # 终止条件
    if left == right:
        return arr[left]

    # 位操作执行效率更高，且自动取整了
    mid = left + ((right - left) >> 1)
    leftMax = process(arr, left, mid)
    rightMax = process(arr, mid + 1, right)
    return max(leftMax, rightMax)

# ------------------------------------------------------------- #


# ------------------- 2.master公式 ------------------- #
'''
T(N) = a * T(n / b) + O(N^d)

T(N)：N是母问题的规模
a * T(n / b)：表示母问题可拆分为 a 个 等量的 规模为 n / b 的子问题
除了子问题之外的复杂度为O(N^d)

总结：可分为子问题等规模的递归问题，都可用master公式求解。
(1)log(b, a) > d : O(N*log(b, a))
(2)          ==  : O(N^d * logN)
(3)          <   : O(N^d)


上述过程的复杂度：T(N) = 2 * T(N /2) + O(1)
a = 2, b = 2, d = 0
log(b, a) = 1 > d = 0   命中第一条：
O(N * log(b, a)) = O(N)

可知与直接遍历的复杂度是一样的。
'''
# --------------------------------------------------- #









