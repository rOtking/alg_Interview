# ----------------------- 1.时间、空间、稳定性 ------------------#
'''
todo
'''
'''
1.选择排序
[3,3,3,1,3,3,3] 第一次选个最小的1与0位置的3交换就已经不稳定了！3的相对位置打乱了。

2.归并在merge时只要先左后右就是稳定的！

3.快排，partition时不稳定！与小于等于区的下一个数交换
)6,6,7,4,..    pivot是5
       i 
此时4与6交换，6的相对位置变了。

4.堆 在开始建立大根堆就不稳定
[5,4,4,6]
    5
   / \
  4   4
 /
6
6要与第一个4交换，4的位置变了。


总结：
       时间     空间      稳定性
选择   O(n^2)   O(1)       No
冒泡   O(n^2)   O(1)       Yes
插入   O(n^2)   O(1)       Yes
归并   O(nlogn) O(n)       Yes
快速   O(nlogn) O(logn)    No
堆     O(nlogn) O(1)       No

一般使用快排，快排经过试验，常数时间是最快的！

对空间有限制，堆。

要求稳定性，归并。

（1）基于比较的排序，O(nlogn)是极限，不会在低了！
（2）时间O(nlogn)，空间O(N)且稳定是不存在的！


'''
# ------------------------------------------------ #


# ----------------------- 2.常见的坑 ------------------#
'''
1.归并空间能不能O(1)？
可以，归并排序-内部缓存法！很难，且丧失稳定性！
那何必呢？用堆不好么？没啥用，理论家的自嗨。

2.原地归并让空间O(1)是垃圾！会让时间O(n^2)，没意义，不如插入呢。

3.快排能稳定，0-1 stable sort，会让空间变为O(n)。   那不如用归并啊！！！

所有的改进都会牺牲原有的一些性质！


题：arr，奇数放左边，偶数右边，相对次序不变！O(nlogn)

partition过程就是0-1过程，小于等于区 + 大于区就是0-1问题，非此即彼。
奇偶也是0-1，也可以partition。但是不稳定。
本地就是想让你实现稳定的快排！做不了 太难！

'''


# ------------------------------------------------ #

# ----------------------- 2.工程改进 ------------------#

'''
大思想还是快排partition，递归partition到比较小的数据范围时如60个，就直接用插入排序完成了。

因为数据少后O(n^2)就不再是瓶颈，而插入排序的常数项很低，综合效果好！


'''
# ------------------------------------------------ #
