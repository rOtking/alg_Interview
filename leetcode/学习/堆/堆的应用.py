
# ------------------- 1.堆排序 ------------------- #
# todo 流程
# 1.原始arr堆化
# 2.输出堆顶，调整堆，保持为最小堆
# 3.重复2过程，直到堆空。

# 时间：初始堆化O(n),n个堆顶元素的删除+调整，每次调整O(logn)，n个元素O(nlogn)
# 空间：O(n)

# todo 放在排序那里专门实现。注意空间这里给的是O(n)，但是其实可以做到O(1)，就是原地排序，堆顶丢到数组末尾，维护一个一排序区即可，
#  未排序区是堆。O(n)就是简单的pop一个用数组存一个。

# ----------------------------------------------- #

# ------------------- 2.topK问题：获取前K个 ------------------- #
# todo 法1 流程
# 1.构建堆；2.pop() k次即可
# 时间 O(Klogn)

# todo 法2 思路
# 如求topK大元素：1.构建容量为K的小根堆；2.每来一个元素，与堆顶比，小与堆顶直接跳过；大于堆顶则进行替换，并调整堆！3.重复2过程直到结束，堆中的就是topK

# 时间 O(nlogK)   n个元素，每个调整步数为logK，因为为何的是大小为K的堆


# ----------------------------------------------- #

# ------------------- 3.Kth问题：获取第K个 ------------------- #

# todo 求第K大 也是两种方法，和topK一样的。
# 1.构建大小为K的小根堆；2.维护小根堆，小的跳过，大的加入调整；3.结束后，堆顶就是

# ----------------------------------------------- #
